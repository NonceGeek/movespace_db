{
    "struct":[],
    "event":[
        "event Transfer(address indexed from,address indexed to,uint256 indexed tokenId);",
        "event Approval(address indexed owner,address indexed approved,uint256 indexed tokenId",
        "event ApprovalForAll(address indexed owner,address indexed operator,bool approved);"
    ],
    "const":[
        "// Equals to `bytes4(keccak256('onERC721Received(address,address,uint256,bytes)'))`// which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;",
        "  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;"
    ],
    "function":[
        "/*** @dev Gets the balance of the specified address* @param owner address to query the balance of* @return uint256 representing the amount owned by the passed address*/\nfunction balanceOf(address owner) public view returns (uint256) { require(owner != address(0)); return _ownedTokensCount[owner];",
        "/*** @dev Gets the owner of the specified token ID* @param tokenId uint256 ID of the token to query the owner of* @return owner address currently marked as the owner of the given token ID*/\nfunction ownerOf(uint256 tokenId) public view returns (address) { address owner = _tokenOwner[tokenId]; require(owner != address(0)); return owner;",
        "/*** @dev Approves another address to transfer the given token ID* The zero address indicates there is no approved address.* There can only be one approved address per token at a given time.* Can only be called by the token owner or an approved operator.* @param to address to be approved for the given token ID* @param tokenId uint256 ID of the token to be approved*/\nfunction approve(address to, uint256 tokenId) public { address owner = ownerOf(tokenId); require(to != owner); require(msg.sender == owner || isApprovedForAll(owner, msg.sender));tokenApprovals[tokenId] = to; emit Approval(owner, to, tokenId);",
        " /*** @dev Gets the approved address for a token ID, or zero if no address set* Reverts if the token ID does not exist.* @param tokenId uint256 ID of the token to query the approval of* @return address currently approved for the given token ID*/\nfunction getApproved(uint256 tokenId) public view returns (address) { require(_exists(tokenId)); return _tokenApprovals[tokenId];",
        "/*** @dev Sets or unsets the approval of a given operator* An operator is allowed to transfer all tokens of the sender on their behalf* @param to operator address to set the approval* @param approved representing the status of the approval to be set*/\nfunction setApprovalForAll(address to, bool approved) public { require(to != msg.sender); _operatorApprovals[msg.sender][to] = approved; emit ApprovalForAll(msg.sender, to, approved);  ",
        "/** * @dev Tells whether an operator is approved by a given owner * @param owner owner address which you want to query the approval of * @param operator operator address which you want to query the approval of * @return bool whether the given operator is approved by the given owner */\nfunction isApprovedForAll(  address owner,  address operator)  public  view  returns (bool){  return _operatorApprovals[owner][operator];}",
        "/** * @dev Transfers the ownership of a given token ID to another address * Usage of this method is discouraged, use `safeTransferFrom` whenever possible * Requires the msg sender to be the owner, approved, or operator * @param from current owner of the token * @param to address to receive the ownership of the given token ID * @param tokenId uint256 ID of the token to be transferred*/\nfunction transferFrom(  address from,  address to,  uint256 tokenId)  public{  require(_isApprovedOrOwner(msg.sender, tokenId));  require(to != address(0));clearApproval(from, tokenId);  _removeTokenFrom(from, tokenId);  _addTokenTo(to, tokenId);emit Transfer(from, to, tokenId);}",
        "/** * @dev Safely transfers the ownership of a given token ID to another address * If the target address is a contract, it must implement `onERC721Received`, * which is called upon a safe transfer, and return the magic value * `bytes4(keccak256('onERC721Received(address,address,uint256,bytes)'))`; otherwise, * the transfer is reverted. * * Requires the msg sender to be the owner, approved, or operator * @param from current owner of the token * @param to address to receive the ownership of the given token ID * @param tokenId uint256 ID of the token to be transferred*/\nfunction safeTransferFrom(  address from,  address to,  uint256 tokenId)  public{  // solium-disable-next-line arg-overflow  safeTransferFrom(from, to, tokenId, '');}",
        "/** * @dev Safely transfers the ownership of a given token ID to another address * If the target address is a contract, it must implement `onERC721Received`, * which is called upon a safe transfer, and return the magic value * `bytes4(keccak256('onERC721Received(address,address,uint256,bytes)'))`; otherwise, * the transfer is reverted. * Requires the msg sender to be the owner, approved, or operator * @param from current owner of the token * @param to address to receive the ownership of the given token ID * @param tokenId uint256 ID of the token to be transferred * @param _data bytes data to send along with a safe transfer check */\nfunction safeTransferFrom(  address from,  address to,  uint256 tokenId,  bytes _data)  public{  transferFrom(from, to, tokenId);  // solium-disable-next-line arg-overflow  require(_checkAndCallSafeTransfer(from, to, tokenId, _data));}",
        "/** * @dev Returns whether the specified token exists * @param tokenId uint256 ID of the token to query the existence of * @return whether the token exists */\nfunction _exists(uint256 tokenId) internal view returns (bool) {  address owner = _tokenOwner[tokenId];  return owner != address(0);}",
        "/** * @dev Returns whether the given spender can transfer a given token ID * @param spender address of the spender to query * @param tokenId uint256 ID of the token to be transferred * @return bool whether the msg.sender is approved for the given token ID, *  is an operator of the owner, or is the owner of the token */\nfunction _isApprovedOrOwner(  address spender,  uint256 tokenId)  internal  view  returns (bool){  address owner = ownerOf(tokenId);  // Disable solium check because of  // https://github.com/duaraghav8/Solium/issues/175  // solium-disable-next-line operator-whitespace  return (    spender == owner ||    getApproved(tokenId) == spender ||    isApprovedForAll(owner, spender)  );}",
        "/** * @dev Internal function to mint a new token * Reverts if the given token ID already exists * @param to The address that will own the minted token * @param tokenId uint256 ID of the token to be minted by the msg.sender */\nfunction _mint(address to, uint256 tokenId) internal {  require(to != address(0));  _addTokenTo(to, tokenId);  emit Transfer(address(0), to, tokenId);}",
        "/** * @dev Internal function to burn a specific token * Reverts if the token does not exist * @param tokenId uint256 ID of the token being burned by the msg.sender */\nfunction _burn(address owner, uint256 tokenId) internal {  _clearApproval(owner, tokenId);  _removeTokenFrom(owner, tokenId);  emit Transfer(owner, address(0), tokenId);}",
        "/** * @dev Internal function to clear current approval of a given token ID * Reverts if the given address is not indeed the owner of the token * @param owner owner of the token * @param tokenId uint256 ID of the token to be transferred */\nfunction _clearApproval(address owner, uint256 tokenId) internal {  require(ownerOf(tokenId) == owner);  if (_tokenApprovals[tokenId] != address(0)) {    _tokenApprovals[tokenId] = address(0);  }}",
        "/** * @dev Internal function to add a token ID to the list of a given address * @param to address representing the new owner of the given token ID * @param tokenId uint256 ID of the token to be added to the tokens list of the given address */\nfunction _addTokenTo(address to, uint256 tokenId) internal {  require(_tokenOwner[tokenId] == address(0));  _tokenOwner[tokenId] = to;  _ownedTokensCount[to] = _ownedTokensCount[to].add(1);}",
        "/** * @dev Internal function to remove a token ID from the list of a given address * @param from address representing the previous owner of the given token ID * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address */\nfunction _removeTokenFrom(address from, uint256 tokenId) internal {  require(ownerOf(tokenId) == from);  _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);  _tokenOwner[tokenId] = address(0);}",
        "/** * @dev Internal function to invoke `onERC721Received` on a target address * The call is not executed if the target address is not a contract * @param from address representing the previous owner of the given token ID * @param to target address that will receive the tokens * @param tokenId uint256 ID of the token to be transferred * @param _data bytes optional data to send along with the call * @return whether the call correctly returned the expected magic value */\nfunction _checkAndCallSafeTransfer(  address from,  address to,  uint256 tokenId,  bytes _data)  internal  returns (bool){  if (!to.isContract()) {    return true;  }  bytes4 retval = IERC721Receiver(to).onERC721Received(    msg.sender, from, tokenId, _data);  return (retval == _ERC721_RECEIVED);}"
    ],
    "variable":[
        "// Mapping from token ID to owner \nmapping (uint256 => address) private _tokenOwner;",
        "// Mapping from token ID to approved address \nmapping (uint256 => address) private _tokenApprovals;",
        "// Mapping from owner to number of owned token \nmapping (address => uint256) private _ownedTokensCount;",
        "// Mapping from owner to operator approvals \nmapping (address => mapping (address => bool)) private _operatorApprovals;"
    ]
}